#pragma once

#include "Asciir/Core/Core.h"
#include "Asciir/Logging/Log.h"
#include "Asciir/Maths/Vector.h"

/*
*	Events are passed to onEvent functions in the application and all of its enabled layers.
*	They function like callbacks but are only called once per application update
*	due to keyboard and mouse callbacks not being possible with the windows api
*	in console applications without global hooks, which makes debbuging with break points very inconvenient.
*	onEvent functions are always called before update functions.
*/

namespace Asciir
{
	/// @brief the type of the category
	/// these enums are what should be used to filter events
	enum class EventType
	{
		NoneType,
		TerminalClosed, TerminalResized, TerminalMoved, TerminalFocus, CursorMoved,
		GameTick, GameUpdate, GameRender,
		KeyPressed, KeyReleased,
		MousePressed, MouseReleased, MouseMoved, MouseScrolled
	};

	/// @brief the category of the event.  
	/// should be used for a more general filtering of events.
	/// 
	/// stored as a bitmask, meaning each category has its own unique bit.
	/// @see CategoryNone
	/// @see CategoryTerminal
	/// @see CategoryInput
	/// @see CategoryKeyboard
	/// @see CategoryMouse
	/// @see CategoryCursor
	typedef int EventCategory;

	/// @brief default category of an event
	constexpr EventCategory CategoryNone = 0;
	/// @brief category related to any events that relate to the terminal
	constexpr EventCategory CategoryTerminal = BIT_SHL(0);
	/// @brief category related to any events that has anything to do with input from external devices
	constexpr EventCategory CategoryInput = BIT_SHL(1);
	/// @brief category for any events generated by keyboard input
	constexpr EventCategory CategoryKeyboard = BIT_SHL(2);
	/// @brief category for any events generated by mouse input
	constexpr EventCategory CategoryMouse = BIT_SHL(3);
	/// @brief category for any events generated by cursor input
	constexpr EventCategory CategoryCursor = BIT_SHL(4);

	/// @brief constant for invalid coordinate values inside event structures, that store coord properties
	static const Coord INVALID_EVENT_COORD{ -1, -1 };

	#define AR_EVENT_IS_VALID AR_ASSERT_MSG(m_valid, "Attempt to acsess value of non valid event.\nName: ", getName(), "\nCategory: ", getCategory(), "\nType:", (int)getType())

	/// @brief abstract class containing data about an event
	/// 
	/// every event structure will inherit from this structure.
	/// provides basic properties like the type of the event and the name of the event.
	/// the event also contains a valid field, and is only set to true if the event has been created properly.
	class Event
	{
	protected:
		bool m_valid = true;
	public:
		/// @brief field for wether the event has been handled.  
		/// if the event is handled, it will not activate any more onEvent fucntions.
		bool handled = false;
		virtual EventType getType() const = 0;
		/// @brief returns the name of the event @see EventCategory.  
		/// @returns the name of the event 
		virtual const char* getName() const = 0;
		virtual EventCategory getCategory() const = 0;
		/// @returns by default returns the name of the event.
		virtual std::string toString() const { return getName(); }
		/// @brief @see toString.
		operator std::string() const { return toString(); }
		/// @returns returns wether the event was generated by a valid source.
		bool isValid() { return m_valid; }

		bool inCategory(EventCategory category)
		{
			return (int)getCategory() & (int)category;
		}
	};

	/// @brief structure responsible for distributing a passed event to any valid event callbacks
	class EventHandler
	{
		template<typename T>
		using EventFp = std::function<bool(T&)>;

		Event& m_event;
	public:
		/// @brief constructor, takes event that should be handled
		/// @param input_event event to be handled
		EventHandler(Event& input_event)
			: m_event(input_event) {}

		/// @brief function responsible for distributing the event to the passed callback
		/// 
		/// should be called, in order, on all the current event callback functions in the application, until it returns true.
		/// @param funcp the callback that should attempt to handle the event
		/// @return returns wether the event was handled or not
		template<typename T>
		bool handle(EventFp<T> funcp)
		{
			// only handle event if the event type matches the callback event type
			if (m_event.getType() == T::getStaticType())
			{
				m_event.handled = funcp(static_cast<T&>(m_event));
				return m_event.handled;
			}
			return false;
		}
	};

/// macro for implementing virtual functions for the specified event type
#define AR_EVENT_TYPE_DEFINE(type) static EventType getStaticType() { return EventType::type; } \
								virtual EventType getType() const override { return getStaticType(); }\
								virtual const char* getName() const override { return #type; } // simply return stringified version of type name

/// macro for implementing virtual functions for the specified event category
#define AR_EVENT_CATEGORY_DEFINE(category) virtual EventCategory getCategory() const override{ return category; }

	/// @brief ostream operator for events
	/// outputs e.toString() to the stream
	inline std::ostream& operator<<(std::ostream& stream, const Event& e)
	{
		stream << e.toString();
		return stream;
	}
}
